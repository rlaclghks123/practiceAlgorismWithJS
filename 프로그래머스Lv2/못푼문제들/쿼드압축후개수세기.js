// 0, 1로 이루어진 2^n x 2^n 크기의 2차원 정수 배열 arr가 있습니다.
// 배열에 최종적으로 남는 0의 개수와 1의 개수를 배열에 담아 return

// 쿼드트리와 같은 방식으로 압축 박스 안에 4개의 박스
// 만약 S내부의 있는 모든 수가 같은 값이라면 S를 해당 수 하나로 압축
// 그렇지 않다면 S를 정확히 4개의 균일한 정사각형 영역으로 쪼갠뒤, 각 영역에 대해 다시 압축

// answer[0,0] 을 통해 0번째 인덱스는 0의 개수, 1번째 인덱스는 1의 개수를 담아준다.
// 1. 0,0, n(arr의 길이)의 인자를 받는 재귀를 통해 모든 좌표를 돌면서 체크를 해준다.
// 2. 만약 n===1인경우 answer에 arr[x][y]값을 담아주고 종료
// 3. 방문처리 flag 값을 true로 만들어준다.
// 4. x,y부터 x+n, y+n까지 다 돌아주면서 처음값과 다르다면 멈추고 방문처리   처음엔 전부 돌고, n/2한 크기를 돌고, ....
// 4. 처음부터 끝까지 돌았는데 방문한적이 없다면 answer에 arr[x][y]값을 담아주고 종료해줍니다.
// 7. 크기를 절반으로 나눠주고, 총 4군데에서 다시 시작해줍니다. 처음엔 큰 사각형, 그다음엔 n//2한 4개의 사각형, 그다음엔 그 4개의 사각형을 다시 n/2한 4개의 사각형 총 16개 .....반복

// ㅁ

// ㅁ ㅁ       x,y      x,y+n
// ㅁ ㅁ       x+n,y    x+n y+n

// ㅁㅁ    ㅁㅁ
// ㅁㅁ    ㅁㅁ

// ㅁㅁ    ㅁㅁ
// ㅁㅁ    ㅁㅁ

function solution(arr) {
  let answer = [0, 0];
  let len = arr.length;

  function check(x, y, n) {
    if (n === 1) return answer[arr[x][y]]++;

    let flag = true;
    for (let i = x; i < x + n; i++) {
      for (let j = y; j < y + n; j++) {
        if (arr[x][y] !== arr[i][j]) {
          flag = false;
          break;
        }
      }
    }
    if (flag) return answer[arr[x][y]]++;
    n /= 2;
    check(x, y, n);
    check(x, y + n, n);
    check(x + n, y, n);
    check(x + n, y + n, n);
  }

  check(0, 0, len);

  return answer;
}

solution([
  [1, 1, 0, 0],
  [1, 0, 0, 0],
  [1, 0, 0, 1],
  [1, 1, 1, 1],
]); // [4,9]

solution([
  [1, 1, 1, 1, 1, 1, 1, 1],
  [0, 1, 1, 1, 1, 1, 1, 1],
  [0, 0, 0, 0, 1, 1, 1, 1],
  [0, 1, 0, 0, 1, 1, 1, 1],
  [0, 0, 0, 0, 0, 0, 1, 1],
  [0, 0, 0, 0, 0, 0, 0, 1],
  [0, 0, 0, 0, 1, 0, 0, 1],
  [0, 0, 0, 0, 1, 1, 1, 1],
]); // [10,15]
